---
title: >
  SvelteKit 1 with SQLite Part 1: Connecting to the DB and displaying data
date: 2023-12-20
description: With two lines in your zsh config file, Oracle SQLcl will still work after an upgrade with Homebrew.
slug: sveltekit-1-with-sqlite-part1
titleImage: ./sveltekit-sqlite-tracks-table.png
titleImageAlt: Photo of a hammer on a wooden background
titleImageSource: { text: 'Photo by iMattSmart
      ', href: 'https://unsplash.com/photos/jaLaLQdkBOE' }
tags: ['Oracle', 'macOS']
ghCommentsIssueId: 67
---

## A perfect match

I think that matching svelte-kit with SQLite is a great Idea as SQLite3 offers all the benefits of a relation database without additional stress of hosting and administering a separate component.

[SQLite is serverless](https://www.sqlite.org/serverless.html) (not the new buzzword) meaning that it runs within the same process from the consuming application. Traditional client/server databases like MySQL or Postgres run in their own process and lead to the burden of maintaining them. This approach can have big advantages if you have a huge amount clients directly connecting to the database. In our svelte-kit approach this is not the case, only the web app directly consumes to the database.

## My setup

I use SvelteKit in combination with TypeScript and highly recommend you doing this as well. We can type our data shapes in the backend and later use them also in the frontend to safely access the data in the UI and make our lives easier in case of structural changes.

I will use [better-sqlite3](https://github.com/WiseLibs/better-sqlite3) as the Node.js SQLite driver as I like it’s synchronous API.

Instead of setting up a schema with data myself I used the [chinook sample database](https://www.sqlitetutorial.net/sqlite-sample-database/) that includes music data with tables like artists, albums and tracks.

## Creating a tracks page

### Setting up the database

As the database file only sits on the server, we can create the main db file in `lib/server`. `lib` is the place to put your code that does not strictly belong to any route. The code can be imported with the `$lib` prefix in the path. Any code in `server` subfolder cannot be imported in the frontend. So any code in there is hidden from the eyes of the site users. You can read more about the project structure in the [docs](https://kit.svelte.dev/docs/project-structure).

I created a subfolder `db` with an `index.ts`. We can import `Database` from `better-sqlite3` and use it's constructor to start our database. I outsourced the path to my database file in a `.env` file with the content `DB_PATH=./data/chinook.db`.

I created the function `getInitialTracks` that just returns the first 50 tracks from the corresponding table. I store the query in a variable and later call `db.prepare` with it. The prepared statement can then be executed with the `.all` function as we want to get multiple rows. This functions also receives an object of the parameters we want to bind to the query. In our case this is the limit amount we can now provide as a function parameter. We don’t want to manually concatenate that input into the SQL-Query as this can lead to nasty SQL-Injection vulnerabilities. The whole file now looks like this:

```typescript
import Database from 'better-sqlite3';
import { DB_PATH } from '$env/static/private';
import type { Track } from './types';

const db = new Database(DB_PATH, { verbose: console.log });

export function getInitialTracks(limit = 50): Track[] {
  const sql = `
  select t.TrackId as trackId
  , t.Name as trackName
  , a.AlbumId as albumId
  , a.Title as albumTitle
  , at.ArtistId as artistId
  , at.Name as artistName
  , g.Name as genre
from tracks t
join albums a
 on t.AlbumId = a.AlbumId
join artists at
 on a.ArtistId = at.ArtistId
join genres g
 on t.GenreId = g.GenreId
limit $limit  
  `;
  const stmnt = db.prepare(sql);
  const rows = stmnt.all({ limit });
  return rows as Track[];
}
```

As I used TypeScript we also need to add a definition for our `Track` type. I created a `types.ts` next to the database `index.ts` with following content:

```typescript
export type Track = {
  trackId: number;
  trackName: string;
  albumId: number;
  albumTitle: string;
  artistId: number;
  artistName: string;
  genre: string;
};
```

### Enriching the page with the data

To show the data on our home page we need to create a `+page.server.ts` in `src/routes`. In there we can add a load function that simply returns the data of our function:

```typescript
import { getInitialTracks } from '$lib/server/db';
import type { PageServerLoad } from './$types';

export const load = (() => {
	const tracks = getInitialTracks();

	return {
		tracks
	};
}) satisfies PageServerLoad;
```

These few lines are enough for us to consume the data in our frontend svelte file. In the neighboring `+page.svelte` we can consume and display the data:

```svelte
<script lang="ts">
	import type { PageData } from './$types';
	export let data: PageData;
<script />

<h1 class="is-size-1">Tracks</h1>

	<table class="table">
		<thead>
			<tr>
				<th>Track</th>
				<th>Artist</th>
				<th>Album</th>
				<th>Genre</th>
			</tr>
		</thead>
		<tbody>
			{#each data.tracks as track}
				<tr>
					<td>{track.trackName}</td>
					<td>{track.artistName}</td>
					<td>{track.albumTitle}</td>
					<td>{track.genre}</td>
				</tr>
			{/each}
		</tbody>
	</table>
```

As I included [bulma](https://bulma.io/) to get some modern initial styles the result looks the following:

<BlogImg
  filename="sveltekit-sqlite-tracks-table.png"
  alt="Table including name, artist, title and genre of tracks originating from the database"
/>

In the next part we will look making the table searchable. We currently only show the first 50 rows of the database table. A search input should trigger a database search and update the table with the matching results.

<SeriesTeaser
  items={['this', 'part2', 'part3']}
  ytLink="https://youtu.be/iO4VUbQ6ua4"
/>
