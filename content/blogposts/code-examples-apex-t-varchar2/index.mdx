---
title: >
  APEX_T_VARCHAR2 is great! #JoelKallmanDay
date: 2022-04-25
lastUpdate: 2022-04-26
description: Maps (not cartography but the data store) are a powerful tool for storing and accessing data in memory. In Oracle PL/SQL they are available too under the name Associative Arrays.
slug: code-examples-apex-t-varchar2
titleImage: ./jan-antonin-kolar-lRoX0shwjUQ-unsplash.jpg
titleImageAlt: A huge warehouse with a lot of big shelves containing identical looking small boxes
titleImageSource:
  {
    text: 'Photo by Jan Antonin Kolar on Unsplash',
    href: 'https://unsplash.com/photos/lRoX0shwjUQ',
  }
tags: ['Oracle', 'APEX']
ghCommentsIssueId: 72
---

## Whats that?

The type `apex_t_varchar2` itself is not that special.
If we open up its declaration we can see that it has a different internal name `wwv_flow_t_varchar2` and is basically just a varchar2 array:

```sql
create or replace type wwv_flow_t_varchar2 as table of varchar2(32767);
```

With arrays you can already do cool stuff but `apex_t_varchar2` gets its superpowers because of the `apex_string` package which is a collection of functions to work with them.

## Use Case 1: Query values that are in a comma separated string of values

Imagine an API where the user can fetch customer data. Your API receives a Customer Code and returns the data for it. Your API currently only accepts one Customer at a time:

```sql
select *
  from customers
 where cust_code = pi_cust_code
```

You can only call the API with one customer code at a time, but the user wants to fetch a few ones most of the time. We can improve this by allowing to pass multiple customer codes as a comma separated string (CUST1,CUST2,CUST3):

```sql
select *
  from customers
 where cust_code member of(
    apex_string.split(pi_csv_cust_codes, ',')
  );
```

If you filter the values based on a number column you can apex_string.split_numbers which returns apex_t_varchar2’s sibling apex_t_number:

```sql
select *
  from customers
 where cust_id member of(
    apex_string.split_numbers(pi_csv_cust_ids, ',')
  );
```

## Use Case 2: Handling Multi Value APEX Items

The most “APEX” thing to do with APEX_T_VARCHAR2 is handling APEX Items that store multiple values. This includes Checkboxes, Shuttles, multi value select lists etc. By default they store the selected values in a single string colon sperated (e. g. `CHESS:FOOTBALL:RACING`).

If we want to store their value in a normalized fashion (one row for each value), we must split these values up before merging them. This can be done in a fast way like the following:

```sql
…
as
 l_fav_sports apex_t_varchar2;
begin
 l_ fav_sports := apex_string.split( pi_fav_sports, ':' );

 -- insert new entries
 insert into people_favorite_sports
   (person_id, sports)
 select pi_person_id, column_value
   from table(l_ fav_sports)
  where column_value not in (select sports from people_favorite_sports where person_id = pi_person_id)
 ;

 -- remove old values that are not selected anymore
 delete from people_favorite_sports
  where person_id = pi_ person_id
    and sports not in (select column_value from table(l_ fav_sports))
 ;
...
```

We first split the colon separated string into our apex_t_varchar2 variable. With the resulting variable we can construct both an insert and delete statement that adds newly selected and removes unselected entries from the table.

## Use Case 3: storing values during long processes

Imagine a PL/SQL data validation process where we validate multiple rows of user data. A user enters all the data, invokes a validation function, and receives a list of errors and warnings.

Because the rows are independent to each other it makes sense to not exit at the first error but instead validate all rows and in the end list all errors and even some warnings.

To conveniently store these feedback messages we can use `apex_t_varchar2`. We create one array for the error messages and one for the warnings. Each time we come across a problem with the user input we add a message to the corresponding array with `apex_string.push`.

```sql
procedure process_user_input (

)
...
begin
  po_errors := apex_t_varchar2();
  po_warnings := apex_t_varchar2();

  for rec in (
    select *
      from user_inputs
     order by line_no asc
  )
  loop
    -- ...
    if user_underage(rec.birthdate) then
      apex_string.push(l_errors, 'Line' || rec.line_no || ': User is too young!');
    end if;

    if not country_code_match(rec.country, rec.phone_number) then
      apex_string.push(l_warnings, 'Line' || rec.line_no || ': Country does not match with phone country code!');
    end if;
    -- ...
  end loop;
  if l_warnings.count > 0 then
    po_warnings_list_html := '<ul><li>' || apex_string.join(l_warnings, '</li><li>') || '</li></ul>';
  end if;

  if l_errors.count > 0 then
    po_status_error := true;
    po_error_list_html := '<ul><li>' || apex_string.join(l_errors, '</li><li>') || '</li></ul>';
  else
    po_status_error := false;
  end if;
  -- ...
end process_user_input;
```

## Use Case 4: Loop Over A Rowtype (kind of)

I like to write code that still works under changing conditions.
I had to implement an E-Mail feature where the end users could define and edit the template.
To make this possible I added a Markdown editor to a page and stored the template in a CLOB column.
Because the E-Mails are sent for a specific data record I allowed them to put placeholders in the template.
These are named after their column name in a specific view and are replaced with the actual value before sending the E-Mail.

I could have just do this manualy for each column but I wanted to make it more generic.
I anticipated that this view and the available placeholders will grow in the future.
So I wanted to loop over all the columns of a single record of that view and dynamically replace the placeholders.

Unfortunately this is not as easy as it sounds.
As far as I know there is no way to loop over a rowtype (please contact me I am wrong).
I would love a native feature where you could just get an (associative array/map)[https://hartenfeller.dev/blog/maps-oracle-plsql] from a rowtype.
So instead I got a bit creative with `APEX_T_VARCHAR2`:

```sql

```

We can instead make two arrays, one for the column names and one for the column values.
The downsides are that we convert every value of that record into a string and that we have to use dynamic SQL.
I try to avoid dynamic SQL because you can get [nasty SQL injection vulnerabilites if you don't sanitize your inputs](https://xkcd.com/327/) but in this case we have no choice.

There is also a different approach to loop over a rowtype with [DBMS_SQL](https://docs.oracle.com/en/database/oracle/oracle-database/21/arpls/DBMS_SQL.html) where you don't lose your types (thanks [Moritz](https://twitter.com/commi235) for pointing that out to me).
[Here is one example](https://github.com/commi235/xlsx_builder/blob/07e6de54ad0a2cf4994a1ec2c64b70d8218db1b4/xlsx_builder_pkg.pkb#L2917-L3053) from [Anton Scheffer's AS_XLSX package](https://technology.amis.nl/languages/oracle-plsql/create-an-excel-file-with-plsql/).
But as you can see the code this is quite complex.
